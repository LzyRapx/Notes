### 51. 说下你对内存的了解？
```
1.栈 - 由编译器自动分配释放
2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，
  未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放
4.另外还有一个专门放常量的地方。- 程序结束释放
5.程序代码区，存放2进制代码。
  在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。
  在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)。
  在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。
  另外，函数中的"adgfdf"这样的字符串存放在常量区。
```
### 52.如何初始化一个指针数组.
```
首先明确一个概念，就是指向数组的指针，和存放指针的数组。 
指向数组的指针：char (*array)[5]; 含义是一个指向存放5个字符的数组的指针。 
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。 
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={“China”,”Beijing”};
其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串”China”和”Beijing”。
```
### 53.关键字const是什么含意？
```
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。
去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的
每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，
只要能说出const意味着“只读”就可以了。
尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。
（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这 个问题，我将问他一个附加的问题：下面的声明都是什么意思？
```
```
const int a;

int const a;

const int *a;

int * const a;

int const * a const;

前两个的作用是一样，a是一个常整型数。
第三个意味着a是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。
第四个意思a是一个指向整 型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型 数是不可修改的，同时指针也是不可修改的）。
如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。
顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，
那么我为什么还要如此看重关键字const呢？我也如下的几下理由： 
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。
如果你曾花很多时间清理 其它人留下的垃圾，你就会很快学会感谢这点多余的信息。
（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。
简而言之，这样可以减少bug的出现。
```
### 54.什么是动态特性?
```
在绝大多数情况下， 程序的功能是在编译的时候就确定下来的， 我们称之为静态特性。 
反之， 如果程序的功能是在运行时刻才能确定下来的， 则称之为动态特性。
C++中， 虚函数，抽象基类， 动态绑定和多态构成了出色的动态特性。
```
### 55.基类的有1个虚函数，子类还需要申明为 virtual吗？为什么。
```
不申明没有关系的。 不过，我总是喜欢显式申明，使得代码更加清晰。
```
### 56.在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？
```
函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern “C”修饰的变量和函数是按照C语言方式编译和连接的。
由于编译后的名字不同，C++程序不能直接调用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。
```
### 57.如何定义Bool变量的TRUE和FALSE的值.
```
一般来说先要把TURE和FALSE给定义了.
使用#define就可以： 
#define TURE 1 
#define FALSE 0 
如果有一个变量需要定义成bool型的，
举个例子：
bool a = TURE;
就可以了
```
### 58.内联函数 inline 和宏定义一起使用的区别.
```
内联函数是在编译的时候已经做好将对应的函数代码替换嵌入到对应的位置，适用于代码较少的函数。 
宏定义是简单的替换变量，如果定义的是有参数的函数形式，参数不做类型校验。
```
### 59.ICMP是什么协议,处于哪一层?
```
Internet控制报文协议，处于网络层（IP层）
```
### 60. C 中 static 有什么作用?
```
(1)隐藏。 
当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，
故使用static在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

(2)static的第二个作用是保持变量内容的持久。
存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
共有两种变量存储在静态存储区：全局变量和static变量。

(3)static的第三个作用是默认初始化为0。
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。
在静态数据区，内存中所有的字节默认值都是0×00,某些时候这一特点可以减少程序员的工作量。
```
### 61. malloc 和 new 的区别。
```
1、malloc/free是C/C++中的方法（函数），new/delete是C++中的操作符。
2、malloc申请的是heap区的内存空间，而new则是申请的free store区的内存空间。
3、使用free之前要判断，使其free的指针是！NULL的，使用delete则无须判断。
4、free掉的内存是该指针指向的一段内存空间，里面应该是空的。而delete掉的内存是里面确实存有数据或者对象的。
```
### 62. malloc 最大能申请多大的内存.(我8G内存能申请1.7G左右)
测试代码：
```
#include <bits/stdc++.h>

using namespace std;

int main(int argc, char const *argv[]) {
  unsigned int blocksize[] = {1024 * 1024, 1024, 1};
  int max = 0;
  for(int i = 0; i < 3; i++) {
    for(int cnt = 1; ; cnt++) {
      void* block = malloc(max + blocksize[i] * cnt);
      if(block) {
        max += blocksize[i] * cnt;
        free(block);
      }
      else {
        break;
      }
    }
  }
  std::cout << "max malloc size = " << max <<  "B \n";
  std::cout << "max malloc size = " << 1. * max / 1024.0 / 1024.0 / 1024.0 << "GB \n";
  return 0;
}

```
### 63.C++ 空类，默认产生哪些成员函数?
```
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符 这四个是我们通常大都知道的。
但是除了这四个，还有两个，那就是取址运算符和 取址运算符 const.
即总共有六个函数。
```
```
class Empty
{
  public:
     Empty(); // 缺省构造函数
     Empty( const Empty& ); // 拷贝构造函数
    ~Empty(); // 析构函数
     Empty& operator=( const Empty& ); // 赋值运算符
     Empty* operator&(); // 取址运算符
     const Empty* operator&() const; // 取址运算符 const
 };
```
```
但是，C++默认生成的函数，只有在被需要的时候，才会产生。
即当我们定义一个类，而不创建类的对象时，就不会创建类的构造函数、析构函数等。
```
### 64.一个程序从开始运行到结束的完整过程？
```
预处理 -> 编译 ->生成.obj文件 -> 汇编 -> 链接 ->生成exe可执行文件.
```
[一个程序从开始运行到结束的完整过程](http://www.cnblogs.com/xidian2014/p/8504580.html)

### 65.手写memcpy() 函数：
```
void *memcpy(void *dest, const void *src, size_t len) {
  if(dest == NULL || src == NULL) {
    return NULL;
  }
  void *ret = dest;
  // memcpy对内存空间有要求的, dest 和 src 所指向的内存空间不能重叠
  // 否则复制的数据是错误的
  if(dest <= src || (char *)dest >= (char *)src + len) }{ 
    // 从前往后拷贝(如果没有重叠区域）
    while(len --) {
      *(char *)dest = *(char *)src;
      dest = (char *)dest + 1;
      src = (char *)src + 1;
    }
  }
  else { // 从后往前拷贝(如果有重叠区域)
    src = (char *)src + len - 1;
    dest = (char *)dest + len - 1;
    while(len --) {
      *(char *) dest = *(char *)src;
      dest = (char *)dest - 1;
      src = (char *)src - 1;
    }
  }
  return ret;
}
```
### 66. 线程和进程各自有什么区别和优劣?
```
1.进程是资源分配的最小单位，线程是程序执行的最小单位。

2.进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

3.线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。
不过如何处理好同步与互斥是编写多线程程序的难点。

4.但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，
而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
```
### 67.封装，继承，多态，抽象
```
1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。
2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。
3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。
4） 抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。
```
### 68. STL中vector，Map，Set的内部实现原理
[STL中vector，Map，Set的内部实现原理](https://www.cnblogs.com/jijiji/p/4861651.html)

### 69. 64位系统int，long，long long分别是几位?
##### 64位
```
char : 1
int : 4
long : 8
long long : 8
```
##### 32位
```
char： 1
int : 4
long : 4
long long : 8
```
[32位与64位系统基本数据类型的字节数](https://blog.csdn.net/u012611878/article/details/52455576)

### 70.手写c++的单例模式，要考虑线程同步
[C++的单例模式与线程安全单例模式（懒汉/饿汉）](https://www.cnblogs.com/qiaoconglovelife/p/5851163.html)

### 71.虚函数的作用：
```
虚函数的作用是减少了对基类的重复，代价是增加了虚表指针的负担(更多的虚表指针)。
```

### 72.当基类有虚函数时。总结：
```
1.每个类都有虚指针和虚表。
2.如果不是虚继承，那么子类将父类的虚指针继承下来，并指向自身的虚表 (发生在对象构造时)，
  有多少个虚函数，虚表里面的项就会有多少。多重继承时，可能存在多个的基类虚表和虚指针。
3.如果是虚继承，那么子类会有两份虚指针，一份指着自己的虚表，一份指向虚基表，多重继承时虚基表与虚基表指针有且只有一份。
```
### 73.虚函数表存放在哪里？
```
1.虚函数表是全局共享的元素,即全局仅有一个.
2.虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段.
3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定.
  即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中.
  根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.
  所以我推测虚函数表和静态成员变量一样,存放在全局区(静态区).
```
### 74.define和inline有什么区别？
```
1：编译阶段：
    宏define在预处理阶段完成；inline在编译阶段
2：类型安全检查:
    inline函数是函数：要做类型检查；
3：替换方式
    define字符串替换；
    inline是指嵌入代码，在编译过程中不单独产生代码，在调用函数的地方不是跳转，
    而是把代码直接写到那里去，对于短小的函数比较实用，且安全可靠。
```
### 75. volatile关键字作用：
```
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，
比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，
从而可以提供对特殊地址的稳定访问.
当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
而且读取的数据立刻被保存。
```

